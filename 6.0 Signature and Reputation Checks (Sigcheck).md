# 6.1 Explain what Authenticode signatures and catalog signing indicate, and their limits

- What Authenticode tells you
  - A file was signed by a code-signing certificate at the time of signing.
  - Windows can validate the signature chain to a trusted root (if the chain is present and trusted).
  - The signer identity is only as trustworthy as the certificate issuance and protection.
- What catalog signing means
  - Some Windows binaries are validated through catalog files rather than an embedded signature.
  - Catalog signing often appears with Windows components and driver-related packages.
- What signatures do NOT prove
  - A signed file can still be malicious (stolen certs, abused signing, malicious-but-signed software).
  - A valid signature does not prove the file is "safe" for your environment.
  - A missing signature does not prove the file is malicious (many legitimate tools are unsigned).
- Limits and common pitfalls
  - Time matters: signing time, compile time, and file system times can disagree.
  - Trust context matters: offline validation, missing intermediates, or enterprise trust stores change results.
  - Attackers can masquerade with lookalike publisher names or repackaged signed binaries.

## 6.2 Use Sigcheck64.exe to review signature status, publisher, timestamps, and file metadata

- Core fields to capture from sigcheck output
  - Signature state (signed/unsigned/invalid)
  - Publisher / signer subject
  - Certificate chain information (where available)
  - Timestamping status (whether a trusted timestamp exists)
  - File version info (CompanyName, ProductName, FileDescription)
  - Compile time and other PE metadata (when shown)
  - Hashes (at least SHA256 for case documentation)
- How to use it in a defensible workflow
  - Run sigcheck against the exact file you will cite in reporting.
  - Record the full path to the file in the evidence or export context.
  - Save the sigcheck output to `logs/` and link it to the case notes.
  - Correlate signature output with where know-good files should live (path and expected publisher).

## 6.3 Identify suspicious signature conditions (unsigned, invalid signature, mismatched publisher, anomalous timestamps, suspicious PE metadata)

- Signature red flags (high signal when correlated with context)
  - Invalid signature or broken chain on a file claiming to be from a major vendor.
  - Signed by an unexpected publisher for the file name or location.
  - Publisher name looks similar to a known vendor (typos, extra spaces, odd punctuation).
  - Embedded signature present but timestamping missing in cases where you'd expect it.
- Path and location mismatches
  - "System-looking" binaries running from user-writable paths (`Downloads`, `AppData`, `Temp`).
  - Signed binaries located in odd directories that do not match vendor install patterns.
- Timestamp anomalies
  - Compile time far in the future or far in the past without a reasonable explanation.
  - File system times that do not line up with install/update events.
  - Timestamp mismatches across related binaries that should be version-aligned.
- PE metadata inconsistencies
  - Blank or generic CompanyName/ProductName for a file claiming to be system software.
  - FileDescription that does not match the binary name or expected function.
  - Suspicious section names, unusual imports, or packing indicators (use as supporting signals).

## 6.4 Explain why reputation is supportive evidence only (local artifacts and context remain primary)

- Reputation is not ground truth
  - It is an external opinion based on prior sightings, telemetry, and reporting.
  - It can be missing for new malware and for niche legitimate tools.
  - It can be misleading for dual-use admin tools and bundled software.
- What matters more than reputation
  - Local execution evidence (process creation artifacts, prefetch, user activity, services/tasks).
  - Persistence linkage (Run keys, tasks, services, WMI, startup folders).
  - Provenance (download source, email attachment chain, browser history, installer traces).
  - Placement and behavior (unexpected path, odd parent process, unusual command line).
- Correct use of reputation checks
  - Use reputation to prioritize, not to conclude.
  - Treat "clean" reputation as non-exculpatory if local evidence is strong.
  - Treat "bad" reputation as a lead that must be corroborated with local artifacts.