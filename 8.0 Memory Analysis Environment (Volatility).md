## 8.1.1 Explain what memory adds beyond disk (in-memory-only activity, running processes, transient network context)

- Memory shows what was live, not just what was stored.
  - Running processes and their command lines.
  - Loaded DLLs/modules and injected code indicators.
  - Network connections and sockets that may never touch disk.
- Memory captures transient artifacts you often cannot recover later.
  - Decrypted content present in RAM (sessions, tokens, plaintext snippets).
  - Short-lived scripts or commands executed and gone.
  - Malware that runs purely in memory (fileless techniques).
- Memory lets you validate execution claims.
  - Confirms whether a suspicious binary actually ran.
  - Links process -> parent -> command line -> associated modules.

## 8.1.2 Identify memory capture types and constraints (raw memory vs crash dumps; completeness and symbol issues)

- Raw memory captures
  - Often best for full visibility when acquired correctly.
  - Can be large and sensitive to acquisition method and compression.
- Windows crash dumps
  - May be complete, kernel, or small (minidump).
  - Small dumps often lack process-level artifacts needed for full triage.
- Common constraints
  - Incomplete captures: missing pages, truncated files, partial acquisition.
  - OS and build mismatches: wrong profile/metadata leads to bad parsing.
  - Symbol dependencies: modern Volatility workflows rely on correct symbol files.
  - Hypervisor/collection artifacts: acquisition tools can introduce noise or gaps.

## 8.1.3 Configure Volatility in the VM environment (paths, dependencies, symbols where required)

- Place Volatility in a stable tools directory.
  - Example: `C:\tools\volatility3\`
- Keep memory images in case-specific storage.
  - Example: `C:\cases\CASE123\evidence\memory\`
- Ensure Python and dependencies are installed if using the Python version.
  - Keep the environment consistent across analysts (same Volatility build).
- Configure symbol storage
  - Use a dedicated symbols directory to avoid re-downloading and to keep cases reproducible.
  - If your environment restricts internet access, stage symbols through an approved method.
- Baseline validation
  - Run an `info`/banner-style check first to confirm the image is supported before burning time on deeper plugins.

## 8.1.4 Execute core workflows (process list/tree, cmdline, loaded modules, network artifacts when supported)

- Process discovery (what ran)
  - List processes to find suspicious names, duplicates, or mismatched paths.
  - Build a process tree to identify parent-child relationships.
- Command line review (how it ran)
  - Pull command line arguments for suspicious processes.
  - Look for LOLBins, encoded PowerShell, suspicious script hosts, or odd flags.
- Module and DLL review (what it loaded)
  - Identify suspicious DLLs, unexpected load paths, and injection indicators.
  - Compare loaded modules to expected baseline for that process type.
- Network context (what it talked to)
  - Enumerate network connections when supported by the image/OS.
  - Tie remote endpoints back to the owning process.
  - Prioritize external IPs, uncommon ports, and processes that should not talk outbound.

## 8.1.5 Correlate memory findings to disk artifacts (process to binary path, persistence linkage, execution traces)

- Process -> binary mapping
  - Extract or identify the on-disk path referenced by the process.
  - Validate the file on disk (hash, signature, compile time, location).
- Persistence linkage
  - If memory shows a suspicious process, hunt persistence that would re-launch it:
    - services, scheduled tasks, Run keys, startup folders, WMI subscriptions
- Execution trace correlation
  - Align memory observation times with disk-based artifacts:
    - event logs, prefetch (if enabled), user activity artifacts, scheduled task logs
- Confidence upgrade rule
  - Memory-only indicator stays a lead until you can tie it to disk evidence or repeated corroboration.
  - Memory + on-disk binary + persistence = strong evidence.

## 8.1.6 Identify common pitfalls (unsupported images, partial captures, symbol mismatches, overinterpreting plugin output)

- Unsupported images
  - Some captures will not parse due to format, OS version, or corruption.
  - Always validate image support early before deep analysis.
- Partial captures
  - Missing pages can hide processes, sockets, or command lines.
  - Treat "no results" as "not observed," not "did not happen."
- Symbol mismatches
  - Wrong symbols produce wrong structures, which produces wrong conclusions.
  - If outputs look nonsensical, stop and validate symbol alignment.
- Plugin overreach
  - Plugins produce indicators, not courtroom-grade truth by themselves.
  - Corroborate with at least one other source (another plugin, disk artifacts, logs).
- Bad assumptions
  - Do not assume a process name implies legitimacy.
  - Do not assume a network connection implies maliciousness without context.